var tipuesearch = {"pages":[{"title":" easy ","text":"easy Fortran shape functions About Interpolation function derived type for standard domains (LaGrange) and infinite domains for finite elements in 1D line elements - standard and infinite+chopped domains, 2D triangle elements - standard domain, quadrilateral elements - standard and infinite+chopped domain, 3D tetrahedron elements - standard domain, hexahedron elements - standard and infinite+chopped domain, wedge/prism elements - standard domain, providing the functions as well as first and second derivatives with respect to the natural coordinates. This derived type depends on the derived type ‘cubatures’ found in the repository ‘fortran cubatures’. See the documentation for details on usage. Infinite domain finite elements Usually, one interpolates the coordinate and solution fields of a finite element with identical shape functions. To interpolate over an infinite domain, one substitutes coordinate shape functions with so-called mapping functions so that the isoparametric domain [-1, 1] maps to [x(-1), infinity]. The provided mapping functions fulfill partition of unity and are suitable for isotropic nodal configurations. The corresponding shape functions for the solution field are modified to accommodate the assumption of a solution value of 0 at the infinite coordinate. These modified shape functions are the function of one greater order, and chopped to achieve nodal isotropy. Usage ! Declare type type ( cubature ) :: scheme type ( shapefunc ) :: shapes character ( 3 ) :: geo = \"HEX\" integer :: order = 1 ! Set cubature call scheme % set ( geo , order + 1 ) ! Set shape functions ! Set domain with \"FIN\" = finite (default), \"INF\" = infinite, \"CHP\" = chopped call shapes % set ( scheme , order , infin = [ \"FIN\" , \"FIN\" , \"INF\" ]) ! Access number of integration points print * , shapes % points ! Access number of nodes print * , shapes % nodes ! Access dimension print * , shapes % dime ! Access shape functions, shape = [nodes, points] print * , shapes % func ! Access shape function derivatives, shape = [dime, nodes, points] print * , shapes % derv ! Access shape function second derivatives, shape = [dime, dime, nodes, points] print * , shapes % curv ! Display nodal coordinates in isoparametric configuration call shapes % numbering () ! Display shape function values and derivatives at each node and integration point call shapes % show () To do Infinite domain wedges Unit testing Developer Info Will Klausler","tags":"home","url":"index.html"},{"title":"Cubature – easy ","text":"type, public :: Cubature This derived type holds data, weights, and abscissae for numerical\nintegration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedrons,\nhexahedrons, and wedges) Note: Cubatures for triangles and tetrahedrons use body coordinates,\nand the condition x1 + x2 + x3 (+ x4) = 1 permits the elimination of\nthe final coordinate. For wedges, the first two coordinates are body,\nthe last is ordinary. Domains:\nLINear - [-1, 1]\nQUAdrilateral - [-1, 1] x [-1, 1]\nTRIangle - [0, 1] x [0, 1-x]\nHEXahedron - [-1, 1] x [-1, 1] x [-1, 1]\nTETrahedron - [0, 1] x [0, 1-x] x [0, 1-x-y]\nWEJ/prism - [0, 1] x [0, 1-x] x [-1, 1] Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: abscissae (:,:) Abscissae (coordinates) integer, public :: dime = 0 Element dimension character(len=3), public :: elmtype = \"\" Element type: TRI, QUA, TET, HEX, WEJ integer, public :: orders (3) = 0 Order of cubature integer, public :: ounit = stdout integer, public :: points = 0 Number of cubature points real(kind=rk), public, allocatable :: weights (:) Weights Finalization Procedures final :: destroy_final private pure subroutine destroy_final(self) Destroy derived type Arguments Type Intent Optional Attributes Name type( Cubature ), intent(inout) :: self Type-Bound Procedures procedure, public :: check private pure function check(self) Check integrity of derived type Arguments Type Intent Optional Attributes Name class( Cubature ), intent(in) :: self Return Value logical procedure, public :: destroy private pure subroutine destroy(self) wipe data and memory Arguments Type Intent Optional Attributes Name class( Cubature ), intent(inout) :: self procedure, public :: set private pure subroutine set(self, elmtype, order) Set cubature scheme by inputting shape and order Arguments Type Intent Optional Attributes Name class( Cubature ), intent(inout) :: self character(len=3), intent(in) :: elmtype Element type: TRI, QUA, TET, HEX, WEJ integer, intent(in) :: order (:) Cubature order: size 1 or dimension procedure, public :: show private  subroutine show(self) Print cubature scheme to output Arguments Type Intent Optional Attributes Name class( Cubature ), intent(in) :: self procedure, public :: summary private  subroutine summary(self) Summarize cubature scheme Arguments Type Intent Optional Attributes Name class( Cubature ), intent(in) :: self Source Code type :: Cubature !! This derived type holds data, weights, and abscissae for numerical !! integration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedrons, !! hexahedrons, and wedges) !! !! Note: Cubatures for triangles and tetrahedrons use body coordinates, !! and the condition x1 + x2 + x3 (+ x4) = 1 permits the elimination of !! the final coordinate. For wedges, the first two coordinates are body, !! the last is ordinary. !! !! Domains: !! LINear - [-1, 1] !! QUAdrilateral - [-1, 1] x [-1, 1] !! TRIangle - [0, 1] x [0, 1-x] !! HEXahedron - [-1, 1] x [-1, 1] x [-1, 1] !! TETrahedron - [0, 1] x [0, 1-x] x [0, 1-x-y] !! WEJ/prism - [0, 1] x [0, 1-x] x [-1, 1] character ( 3 ) :: elmtype = \"\" !! Element type: TRI, QUA, TET, HEX, WEJ integer :: dime = 0 !! Element dimension integer :: orders ( 3 ) = 0 !! Order of cubature integer :: points = 0 !! Number of cubature points real ( rk ), allocatable :: abscissae (:,:) !! Abscissae (coordinates) real ( rk ), allocatable :: weights (:) !! Weights integer :: ounit = stdout contains ! Fulfill object requirements procedure :: check procedure :: summary procedure :: show procedure :: destroy ! Unique procedures procedure :: set final :: destroy_final end type Cubature","tags":"","url":"type/cubature.html"},{"title":"Shapefunc – easy ","text":"type, public :: Shapefunc Includes Lagrange shape functions, linear - quartic, over the domains\n         [-1, 1] and [0, 1]\nFirst and second order mapping functions for [-1, 1] with infinity at 1 Note: Cubatures for tetrahedra use body coordinates, and the condition\n      x1 + x2 + x3 + x4 = 1 allows the elimination of the final\n      coordinate (likewise with triangles) Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: curv (:,:,:,:) Shape function second derivatives (dimension,dimension,nodes,points) real(kind=rk), public, allocatable :: derv (:,:,:) Shape function first derivatives (dimension,nodes,points) integer(kind=ik), public :: dime = 0 Dimension character(len=3), public :: elmtype = \"\" Element type real(kind=rk), public, allocatable :: func (:,:) Shape function values (nodes,points) character(len=3), public :: inf (3) = [\"FIN\", \"FIN\", \"FIN\"] Infinitude procedure(lagrpoly), public, pointer, nopass :: lagrange1 procedure(lagrpoly), public, pointer, nopass :: lagrange2 procedure(lagrpoly), public, pointer, nopass :: lagrange3 integer(kind=ik), public :: nodes = 0 Nodes integer(kind=ik), public :: order = 0 Order integer, public :: ounit = stdout integer(kind=ik), public :: points = 0 Cubature points integer(kind=ik), public, allocatable :: seq (:,:) Nodal numbering sequence Finalization Procedures final :: destroy_final private pure subroutine destroy_final(self) Destroy derived type Arguments Type Intent Optional Attributes Name type( Shapefunc ), intent(inout) :: self Type-Bound Procedures procedure, public :: check private pure function check(self) Check integrity of instance Arguments Type Intent Optional Attributes Name class( Shapefunc ), intent(in) :: self Return Value logical procedure, public :: destroy private pure subroutine destroy(self) Reset type to initial state Arguments Type Intent Optional Attributes Name class( Shapefunc ), intent(inout) :: self procedure, public :: eval private pure subroutine eval(self, cord, func, derv, curv) Evaluate shape functions and derivatives at a point Arguments Type Intent Optional Attributes Name class( Shapefunc ), intent(in) :: self real(kind=rk), intent(in) :: cord (self%dime) Point at which to evaluate real(kind=rk), intent(out) :: func (self%nodes) Shape function values real(kind=rk), intent(out) :: derv (self%dime,self%nodes) Shape function derivatives real(kind=rk), intent(out) :: curv (self%dime,self%dime,self%nodes) Shape function second derivatives procedure, public :: numbering private  subroutine numbering(self) Print node numbers and coordinates Arguments Type Intent Optional Attributes Name class( Shapefunc ), intent(in) :: self procedure, public :: set private pure subroutine set(self, cube, order, infin) Set shape functions given a cubature and a shape function code\n - cubature and shape functions must be compatible ! Set order and sequences ! Calculate shape functions and derivatives Arguments Type Intent Optional Attributes Name class( Shapefunc ), intent(inout) :: self class( Cubature ), intent(in) :: cube Cubature derived type integer(kind=ik), intent(in) :: order Shape function order character(len=3), intent(in), optional :: infin (:) Infinitude or chopitude along each direction procedure, public :: show private  subroutine show(self) Print shape function values and derivatives to terminal Arguments Type Intent Optional Attributes Name class( Shapefunc ), intent(in) :: self procedure, public :: summary private  subroutine summary(self) Summary contents to file Arguments Type Intent Optional Attributes Name class( Shapefunc ), intent(in) :: self Source Code type :: Shapefunc !! Includes Lagrange shape functions, linear - quartic, over the domains !!          [-1, 1] and [0, 1] !! First and second order mapping functions for [-1, 1] with infinity at 1 !! Note: Cubatures for tetrahedra use body coordinates, and the condition !!       x1 + x2 + x3 + x4 = 1 allows the elimination of the final !!       coordinate (likewise with triangles) character ( 3 ) :: elmtype = \"\" !! Element type integer ( ik ) :: dime = 0 !! Dimension integer ( ik ) :: order = 0 !! Order integer ( ik ) :: nodes = 0 !! Nodes integer ( ik ) :: points = 0 !! Cubature points character ( 3 ) :: inf ( 3 ) = [ \"FIN\" , \"FIN\" , \"FIN\" ] !! Infinitude real ( rk ), allocatable :: func (:,:) !! Shape function values (nodes,points) real ( rk ), allocatable :: derv (:,:,:) !! Shape function first derivatives (dimension,nodes,points) real ( rk ), allocatable :: curv (:,:,:,:) !! Shape function second derivatives (dimension,dimension,nodes,points) ! Internally useful ! Function pointers procedure ( lagrpoly ), pointer , nopass :: lagrange1 , lagrange2 , lagrange3 integer ( ik ), allocatable :: seq (:,:) !! Nodal numbering sequence integer :: ounit = stdout contains ! Fulfill object requirements procedure :: check procedure :: summary procedure :: show procedure :: numbering procedure :: destroy ! Unique procedures procedure :: set procedure :: eval final :: destroy_final end type Shapefunc","tags":"","url":"type/shapefunc.html"},{"title":"counter – easy","text":"public pure function counter(i, j, k, r) result(c) Count in base r - indexing starts at 1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: r (3) Return Value integer Source Code pure function counter ( i , j , k , r ) result ( c ) !! Count in base r - indexing starts at 1 integer , intent ( in ) :: i , j , k , r ( 3 ) integer :: c c = r ( 2 ) * r ( 3 ) * ( i - 1 ) + r ( 3 ) * ( j - 1 ) + ( k - 1 ) + 1 end function counter","tags":"","url":"proc/counter.html"},{"title":"is_zero – easy","text":"pure elemental function is_zero(r) result(z) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: r Return Value logical Source Code pure elemental function is_zero ( r ) result ( z ) real ( rk ), intent ( in ) :: r logical :: z z = abs ( r ) < 1 0.0_rk ** ( - 12 ) end function is_zero","tags":"","url":"proc/is_zero.html"},{"title":"cubatures – easy","text":"Define cubature derived type Uses iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=3), public, parameter :: elmtypes (*) = [\"LIN\", \"TRI\", \"QUA\", \"TET\", \"HEX\", \"WEJ\"] integer, public, parameter :: maxorders (*) = [5, 3, 5, 3, 5, 3] real(kind=rk), public, parameter :: volumes (*) = [2.0_rk, 1.0_rk/2, 4.0_rk, 1.0_rk/6, 8.0_rk, 1.0_rk] Derived Types type, public :: Cubature This derived type holds data, weights, and abscissae for numerical\nintegration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedrons,\nhexahedrons, and wedges) Read more… Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: abscissae (:,:) Abscissae (coordinates) integer, public :: dime = 0 Element dimension character(len=3), public :: elmtype = \"\" Element type: TRI, QUA, TET, HEX, WEJ integer, public :: orders (3) = 0 Order of cubature integer, public :: ounit = stdout integer, public :: points = 0 Number of cubature points real(kind=rk), public, allocatable :: weights (:) Weights Finalizations Procedures final :: destroy_final Type-Bound Procedures procedure, public :: check procedure, public :: destroy procedure, public :: set procedure, public :: show procedure, public :: summary Functions public pure function counter (i, j, k, r) result(c) Count in base r - indexing starts at 1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: r (3) Return Value integer","tags":"","url":"module/cubatures.html"},{"title":"shapefuncs – easy","text":"Procedures for evaluating shape and map functions and derivatives for\n triangles, quadrilateral, tetrahedron, and hexahedron elements\n Use cubature module with derived type Uses cubatures iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: shaporders (*) = [4, 4, 4, 4, 2] Derived Types type, public :: Shapefunc Includes Lagrange shape functions, linear - quartic, over the domains\n         [-1, 1] and [0, 1]\nFirst and second order mapping functions for [-1, 1] with infinity at 1 Read more… Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: curv (:,:,:,:) Shape function second derivatives (dimension,dimension,nodes,points) real(kind=rk), public, allocatable :: derv (:,:,:) Shape function first derivatives (dimension,nodes,points) integer(kind=ik), public :: dime = 0 Dimension character(len=3), public :: elmtype = \"\" Element type real(kind=rk), public, allocatable :: func (:,:) Shape function values (nodes,points) character(len=3), public :: inf (3) = [\"FIN\", \"FIN\", \"FIN\"] Infinitude procedure(lagrpoly), public, pointer, nopass :: lagrange1 procedure(lagrpoly), public, pointer, nopass :: lagrange2 procedure(lagrpoly), public, pointer, nopass :: lagrange3 integer(kind=ik), public :: nodes = 0 Nodes integer(kind=ik), public :: order = 0 Order integer, public :: ounit = stdout integer(kind=ik), public :: points = 0 Cubature points integer(kind=ik), public, allocatable :: seq (:,:) Nodal numbering sequence Finalizations Procedures final :: destroy_final Type-Bound Procedures procedure, public :: check procedure, public :: destroy procedure, public :: eval procedure, public :: numbering procedure, public :: set procedure, public :: show procedure, public :: summary","tags":"","url":"module/shapefuncs.html"},{"title":"shapefuncs_example – easy","text":"Uses shapefuncs cubatures Demonstrate shape functions Variables Type Attributes Name Initial type( Cubature ) :: cuba type( Shapefunc ) :: shaper Source Code program shapefuncs_example !! Demonstrate shape functions use cubatures use shapefuncs implicit none type ( Cubature ) :: cuba type ( Shapefunc ) :: shaper call cuba % set ( \"HEX\" ,[ 2 ]) call shaper % set ( cuba , 2 ) call shaper % show () call shaper % numbering () end program shapefuncs_example","tags":"","url":"program/shapefuncs_example.html"},{"title":"shapefuncs_test – easy","text":"Uses shapefuncs cubatures iso_fortran_env Validate shape functions Variables Type Attributes Name Initial character(len=*), parameter :: fmt1 = \"(A15,': ',$)\" integer :: g integer :: i integer :: j integer :: maxo integer :: ord character(len=1) :: order type( Cubature ) :: scheme type( Shapefunc ) :: shape Functions pure elemental function is_zero (r) result(z) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: r Return Value logical Source Code program shapefuncs_test !! Validate shape functions use iso_fortran_env , only : ik => int32 , rk => real64 , stdout => output_unit use cubatures , only : cubature , elmtypes use shapefuncs , only : shapefunc , shaporders implicit none integer :: g , i , j integer :: ord integer :: maxo ! real(rk) :: character ( 1 ) :: order character ( * ), parameter :: fmt1 = \"(A15,': ',$)\" type ( cubature ) :: scheme type ( shapefunc ) :: shape write ( * , \"(A)\" ) \"1D elements\" write ( * , fmt1 ) \"Line\" j = maxval ( maxloc ( index ( elmtypes , \"LIN\" ))) maxo = shaporders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"LIN\" , [ i ]) ! Standard domain call shape % set ( scheme , i ) do g = 1 , shape % points if (. not . is_zero ( sum ( shape % func (:, g )) - 1.0_rk )) then write ( * , * ) write ( * , * ) sum ( shape % func ) error stop \"order \" // order // \" standard: partition of unity failed\" end if if (. not . is_zero ( sum ( shape % derv ( 1 ,:, g )))) then write ( * , * ) write ( * , * ) sum ( shape % derv ( 1 ,:, g )) error stop \"order \" // order // \" standard: derivatives failed\" end if end do ! g ! Infinite domain call shape % set ( scheme , i , infin = [ \"INF\" ]) do g = 1 , shape % points if (. not . is_zero ( sum ( shape % func (:, g )) - 1.0_rk )) then write ( * , * ) write ( * , * ) sum ( shape % func ) error stop \"order \" // order // \" infinite: partition of unity failed\" end if if (. not . is_zero ( sum ( shape % derv ( 1 ,:, g )))) then write ( * , * ) write ( * , * ) sum ( shape % derv ( 1 ,:, g )) error stop \"order \" // order // \" infinite: derivatives failed\" end if end do ! g end do ! i write ( * , \"(A)\" ) \"passed\" contains pure elemental function is_zero ( r ) result ( z ) real ( rk ), intent ( in ) :: r logical :: z z = abs ( r ) < 1 0.0_rk ** ( - 12 ) end function is_zero end program shapefuncs_test","tags":"","url":"program/shapefuncs_test.html"},{"title":"shapefuncs_example.f90 – easy","text":"Source Code program shapefuncs_example !! Demonstrate shape functions use cubatures use shapefuncs implicit none type ( Cubature ) :: cuba type ( Shapefunc ) :: shaper call cuba % set ( \"HEX\" ,[ 2 ]) call shaper % set ( cuba , 2 ) call shaper % show () call shaper % numbering () end program shapefuncs_example","tags":"","url":"sourcefile/shapefuncs_example.f90.html"},{"title":"cubatures.f90 – easy","text":"Source Code module cubatures !! Define cubature derived type use iso_fortran_env , only : rk => real64 , stdout => output_unit implicit none private character ( 3 ), parameter :: elmtypes ( * ) = & [ \"LIN\" , \"TRI\" , \"QUA\" , \"TET\" , \"HEX\" , \"WEJ\" ] real ( rk ), parameter :: volumes ( * ) = & [ 2.0_rk , 1.0_rk / 2 , 4.0_rk , 1.0_rk / 6 , 8.0_rk , 1.0_rk ] integer , parameter :: maxorders ( * ) = & [ 5 , 3 , 5 , 3 , 5 , 3 ] public :: elmtypes , volumes , maxorders type :: Cubature !! This derived type holds data, weights, and abscissae for numerical !! integration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedrons, !! hexahedrons, and wedges) !! !! Note: Cubatures for triangles and tetrahedrons use body coordinates, !! and the condition x1 + x2 + x3 (+ x4) = 1 permits the elimination of !! the final coordinate. For wedges, the first two coordinates are body, !! the last is ordinary. !! !! Domains: !! LINear - [-1, 1] !! QUAdrilateral - [-1, 1] x [-1, 1] !! TRIangle - [0, 1] x [0, 1-x] !! HEXahedron - [-1, 1] x [-1, 1] x [-1, 1] !! TETrahedron - [0, 1] x [0, 1-x] x [0, 1-x-y] !! WEJ/prism - [0, 1] x [0, 1-x] x [-1, 1] character ( 3 ) :: elmtype = \"\" !! Element type: TRI, QUA, TET, HEX, WEJ integer :: dime = 0 !! Element dimension integer :: orders ( 3 ) = 0 !! Order of cubature integer :: points = 0 !! Number of cubature points real ( rk ), allocatable :: abscissae (:,:) !! Abscissae (coordinates) real ( rk ), allocatable :: weights (:) !! Weights integer :: ounit = stdout contains ! Fulfill object requirements procedure :: check procedure :: summary procedure :: show procedure :: destroy ! Unique procedures procedure :: set final :: destroy_final end type Cubature public :: Cubature public :: counter contains !*********************************************************************** pure function check ( self ) !! Check integrity of derived type class ( cubature ), intent ( in ) :: self logical :: check check = ( allocated ( self % abscissae ) . neqv . allocated ( self % weights )) end function check !*********************************************************************** subroutine summary ( self ) !! Summarize cubature scheme class ( cubature ), intent ( in ) :: self associate ( u => self % ounit ) write ( u , \"(A20,A)\" ) \"Element type: \" , self % elmtype write ( u , \"(A20,I0)\" ) \"Element dimension: \" , self % dime write ( u , \"(A20,3(I1,:,','))\" ) \"Element orders: \" , self % orders write ( u , \"(A20,I0)\" ) \"Element points: \" , self % points end associate end subroutine summary !*********************************************************************** subroutine show ( self ) !! Print cubature scheme to output class ( Cubature ), intent ( in ) :: self integer :: i character ( * ), parameter :: fmt0 = \"*(G0,:,', ')\" character ( * ), parameter :: fmt1 = \"(I3,')',1x,\" // fmt0 // \")\" character ( * ), parameter :: fmt2 = \"('Chk:',1x,\" // fmt0 // \")\" write ( self % ounit , \"(A)\" ) \"CUBATURE DATA\" select case ( self % elmtype ) ! Information on lines case ( \"LIN\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"LIN\" , self % orders ( 1 ), \"Abscissae (1), Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , self % abscissae (:, i ), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) sum ( self % abscissae ( 1 ,:)), sum ( self % weights ) ! Information on quadrilaterals case ( \"QUA\" ) write ( self % ounit , \"(A,2I2,1x,A)\" ) \"QUA\" , self % orders ( 1 : 2 ), \"Abscissae (2), Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , self % abscissae (:, i ), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)), i = 1 , 2 ), sum ( self % weights ) ! Information on triangles case ( \"TRI\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"TRI\" , self % orders ( 1 ), \"Abscissae (2), Coord 3, Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , & self % abscissae (:, i ), & 1 - sum ( self % abscissae (:, i )), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)) / self % points , i = 1 , 2 ), & 1 - sum ( self % abscissae (:,:)) / self % points , & sum ( self % weights ) ! Information on hexahedra case ( \"HEX\" ) write ( self % ounit , \"(A,3I2,1x,A)\" ) \"HEX\" , self % orders , \"Abscissae (3), Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , self % abscissae (:, i ), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)), i = 1 , 3 ), sum ( self % weights ) ! Information on tetrahedra case ( \"TET\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"TET\" , self % orders ( 1 ), \"Abscissae (3), Coord 4, Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , & self % abscissae (:, i ), & 1 - sum ( self % abscissae (:, i )), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)) / self % points , i = 1 , 3 ), & 1 - sum ( self % abscissae (:,:)) / self % points , & sum ( self % weights ) ! Information on wedges case ( \"WEJ\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"WEJ\" , self % orders ( 1 ), \"Abscissae (1-2), Coord 3, Abscissa 3, Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , & self % abscissae ( 1 : 2 , i ), & 1 - sum ( self % abscissae ( 1 : 2 , i )), & self % abscissae ( 3 , i ), & self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) sum ( self % abscissae ( 1 ,:)) / self % points , & sum ( self % abscissae ( 2 ,:)) / self % points , & 1 - sum ( self % abscissae ( 1 : 2 ,:)) / self % points , & sum ( self % abscissae ( 3 ,:)) / self % points , & sum ( self % weights ) end select write ( self % ounit , * ) end subroutine show !*********************************************************************** pure subroutine destroy ( self ) !! wipe data and memory class ( Cubature ), intent ( inout ) :: self self % elmtype = \"\" self % orders = 0 self % points = 0 if ( allocated ( self % abscissae )) deallocate ( self % abscissae ) if ( allocated ( self % weights )) deallocate ( self % weights ) self % ounit = stdout end subroutine destroy !*********************************************************************** pure subroutine destroy_final ( self ) !! Destroy derived type type ( Cubature ), intent ( inout ) :: self call self % destroy () end subroutine destroy_final !*********************************************************************** pure subroutine set ( self , elmtype , order ) !! Set cubature scheme by inputting shape and order class ( Cubature ), intent ( inout ) :: self character ( 3 ), intent ( in ) :: elmtype !! Element type: TRI, QUA, TET, HEX, WEJ integer , intent ( in ) :: order (:) !! Cubature order: size 1 or dimension integer :: i , j , k !! Iterators integer :: n !! Index of abscissae ! Wipe any existing data call self % destroy () ! Set data self % elmtype = elmtype select case ( self % elmtype ) case ( \"LIN\" ) self % dime = 1 case ( \"TRI\" , \"QUA\" ) self % dime = 2 case ( \"HEX\" , \"TET\" , \"WEJ\" ) self % dime = 3 end select ! Read order select case ( size ( order , 1 )) case ( 1 ) self % orders ( 1 ) = order ( 1 ) if ( self % orders ( 1 ) > 0 ) then self % orders ( 1 : self % dime ) = order ( 1 ) self % orders ( self % dime + 1 : 3 ) = 1 end if case ( 2 ) if (( self % elmtype == \"HEX\" ) . or . ( self % elmtype == \"TET\" ) . or . ( self % elmtype == \"WEJ\" )) then error stop \"cubatures%set: Invalid order array for 3D\" end if if ( self % elmtype == \"LIN\" ) then error stop \"cubatures%set: Invalid order array for 1D\" end if self % orders ( 1 : 2 ) = order self % orders ( 3 ) = 1 case ( 3 ) if (( self % elmtype == \"QUA\" ) . or . ( self % elmtype == \"TRI\" )) then error stop \"cubatures%set: Invalid order array for 2D\" end if if ( self % elmtype == \"LIN\" ) then error stop \"cubatures%set: Invalid order array for 1D\" end if self % orders = order end select select case ( self % elmtype ) case ( \"LIN\" ) self % points = self % orders ( 1 ) ! Allocate memory allocate ( self % abscissae ( 1 : 1 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( maxval ( self % orders )) real ( rk ) :: weights ( maxval ( self % orders )) ! Retrieve lineature call gauss ( self % orders ( 1 ), abscissae , weights ) ! Accumulate cubature do i = 1 , self % orders ( 1 ) n = counter ( i , 1 , 1 , self % orders ) self % abscissae ( 1 , n ) = abscissae ( i ) self % weights ( n ) = weights ( i ) end do ! i end block case ( \"QUA\" ) self % points = self % orders ( 1 ) * self % orders ( 2 ) ! Allocate memory allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( maxval ( self % orders ), 2 ) real ( rk ) :: weights ( maxval ( self % orders ), 2 ) ! Retrieve lineature call gauss ( self % orders ( 1 ), abscissae (:, 1 ), weights (:, 1 )) call gauss ( self % orders ( 2 ), abscissae (:, 2 ), weights (:, 2 )) ! Accumulate cubature do i = 1 , self % orders ( 1 ) do j = 1 , self % orders ( 2 ) n = counter ( i , j , 1 , self % orders ) self % abscissae (:, n ) = [ abscissae ( i , 1 ), abscissae ( j , 2 )] self % weights ( n ) = weights ( i , 1 ) * weights ( j , 2 ) end do ! j end do ! i end block case ( \"TRI\" ) select case ( self % orders ( 1 )) ! 1-Point triangle quadrature case ( 1 ) self % points = 1 allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 ) = 1.0_rk / 3 self % weights ( 1 ) = 1.0_rk / 2 ! 3-Point triangle quadrature - interior (see Zienkiewicz & Taylor) case ( 2 ) self % points = 3 allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae = 1.0_rk / 6 self % abscissae ( 1 , 1 ) = 2.0_rk / 3 self % abscissae ( 2 , 2 ) = 2.0_rk / 3 self % weights = 1.0_rk / 6 ! 4-Point triangle quadrature - interior case ( 3 ) self % points = 4 allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 ) = 1.0_rk / 3 self % abscissae (:, 2 : 4 ) = 0.2_rk self % abscissae ( 1 , 2 ) = 0.6_rk self % abscissae ( 2 , 3 ) = 0.6_rk self % weights ( 1 ) = - 2 7.0_rk / 96 self % weights ( 2 : 4 ) = 2 5.0_rk / 96 case default error stop \"Cubature%set: Invalid order for triangle\" end select case ( \"HEX\" ) if ( self % orders ( 2 ) > 0 ) then self % points = product ( self % orders ) ! Allocate memory allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( maxval ( self % orders ), 3 ) real ( rk ) :: weights ( maxval ( self % orders ), 3 ) ! Retrieve lineature do i = 1 , 3 call gauss ( self % orders ( i ), abscissae (:, i ), weights (:, i )) end do ! i ! Accumulate cubature do i = 1 , self % orders ( 1 ) do j = 1 , self % orders ( 2 ) do k = 1 , self % orders ( 3 ) n = counter ( i , j , k , self % orders ) self % abscissae (:, n ) = [ abscissae ( i , 1 ), abscissae ( j , 2 ), abscissae ( k , 3 )] self % weights ( n ) = weights ( i , 1 ) * weights ( j , 2 ) * weights ( k , 3 ) end do ! k end do ! j end do ! i end block ! 4-Point hexahedron cubature else if ( self % orders ( 1 ) == - 4 ) then self % points = 4 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ), parameter :: sqrt13 = sqrt ( 1.0_rk / 3 ) self % abscissae (:, 1 ) = [ - sqrt13 , - sqrt13 , - sqrt13 ] self % abscissae (:, 2 ) = [ sqrt13 , sqrt13 , - sqrt13 ] self % abscissae (:, 3 ) = [ sqrt13 , - sqrt13 , sqrt13 ] self % abscissae (:, 4 ) = [ - sqrt13 , sqrt13 , sqrt13 ] self % weights = 2 end block ! 9-Point hexahedron cubature else if ( self % orders ( 1 ) == - 9 ) then self % points = 9 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ), parameter :: sqrt35 = sqrt ( 3.0_rk / 5 ) real ( rk ), parameter :: tick ( 1 : 2 ) = [ - sqrt35 , sqrt35 ] self % weights ( 1 : 8 ) = 5.0_rk / 9 self % weights ( 9 ) = 3 2.0_rk / 9 do i = 1 , 2 do j = 1 , 2 do k = 1 , 2 n = counter ( i , j , k ,[ 2 , 2 , 2 ]) self % abscissae (:, n ) = [ tick ( k ), tick ( j ), tick ( i )] end do ! k end do ! j end do ! i self % abscissae (:, 9 ) = 0 end block else error stop \"Cubature%set: Invalid order for hexahedron\" end if case ( \"TET\" ) select case ( self % orders ( 1 )) ! 1-Point tetrahedron cubature case ( 1 ) self % points = 1 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 ) = 0.25_rk self % weights ( 1 ) = 1.0_rk / 6 ! 4-Point tetrahedron cubature - interior (see Zienkiewicz & Taylor) case ( 2 ) self % points = 4 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ), parameter :: alpha = 0.5854101966249685_rk real ( rk ), parameter :: beta = 0.1381966011250105_rk self % abscissae = beta do i = 1 , 3 self % abscissae ( i , i ) = alpha end do ! i end block self % weights = 1.0_rk / 24 ! 5-Point tetrahedron cubature - interior case ( 3 ) self % points = 5 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 : 4 ) = 1.0_rk / 6 self % abscissae ( 1 , 1 ) = 0.5_rk self % abscissae ( 2 , 2 ) = 0.5_rk self % abscissae ( 3 , 3 ) = 0.5_rk self % abscissae (:, 5 ) = 0.25_rk self % weights ( 1 : 4 ) = 0.45_rk / 6 self % weights ( 5 ) = - 0.8_rk / 6 case default error stop \"Cubature%set: Invalid order for tetrahedron\" end select case ( \"WEJ\" ) select case ( self % orders ( 1 )) ! 2-Point wedge cubature case ( 1 ) self % points = 2 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( 2 ) real ( rk ) :: weights ( 2 ) call gauss ( 2 , abscissae , weights ) self % abscissae ( 1 : 2 ,:) = 1.0_rk / 3 self % abscissae ( 3 ,:) = abscissae self % weights = 0.5_rk * weights end block ! 9-Point wedge cubature case ( 2 ) self % points = 9 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( 3 ) real ( rk ) :: weights ( 3 ) call gauss ( 3 , abscissae , weights ) self % abscissae ( 1 : 2 ,:) = 1.0_rk / 6 self % abscissae ( 1 , 1 ) = 2.0_rk / 3 self % abscissae ( 2 , 2 ) = 2.0_rk / 3 self % abscissae ( 1 , 4 ) = 2.0_rk / 3 self % abscissae ( 2 , 5 ) = 2.0_rk / 3 self % abscissae ( 1 , 7 ) = 2.0_rk / 3 self % abscissae ( 2 , 8 ) = 2.0_rk / 3 self % abscissae ( 3 , 1 : 3 ) = abscissae ( 1 ) self % abscissae ( 3 , 4 : 6 ) = abscissae ( 2 ) self % abscissae ( 3 , 7 : 9 ) = abscissae ( 3 ) self % weights ( 1 : 3 ) = 1.0_rk / 6 * weights ( 1 ) self % weights ( 4 : 6 ) = 1.0_rk / 6 * weights ( 2 ) self % weights ( 7 : 9 ) = 1.0_rk / 6 * weights ( 3 ) end block ! 16-Point wedge cubature case ( 3 ) self % points = 16 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( 4 ) real ( rk ) :: weights ( 4 ) call gauss ( 4 , abscissae , weights ) do i = 1 , 4 self % abscissae ( 1 : 2 , 4 * ( i - 1 ) + 1 ) = 1.0_rk / 3 self % abscissae ( 1 : 2 , 4 * ( i - 1 ) + 2 ) = [ 0.6_rk , 0.2_rk ] self % abscissae ( 1 : 2 , 4 * ( i - 1 ) + 3 ) = [ 0.2_rk , 0.6_rk ] self % abscissae ( 1 : 2 , 4 * ( i - 1 ) + 4 ) = 0.2_rk end do ! i self % abscissae ( 3 , 1 : 4 ) = abscissae ( 1 ) self % abscissae ( 3 , 5 : 8 ) = abscissae ( 2 ) self % abscissae ( 3 , 9 : 12 ) = abscissae ( 3 ) self % abscissae ( 3 , 13 : 16 ) = abscissae ( 4 ) do i = 1 , 4 self % weights ( 4 * ( i - 1 ) + 1 ) = - 2 7.0_rk / 96 * weights ( i ) self % weights ( 4 * ( i - 1 ) + 2 ) = 2 5.0_rk / 96 * weights ( i ) self % weights ( 4 * ( i - 1 ) + 3 ) = 2 5.0_rk / 96 * weights ( i ) self % weights ( 4 * ( i - 1 ) + 4 ) = 2 5.0_rk / 96 * weights ( i ) end do ! i end block case default error stop \"Cubature%set: Invalid order for wedge\" end select case default error stop \"Cubature%set: Invalid element type\" end select end subroutine set !*********************************************************************** pure function counter ( i , j , k , r ) result ( c ) !! Count in base r - indexing starts at 1 integer , intent ( in ) :: i , j , k , r ( 3 ) integer :: c c = r ( 2 ) * r ( 3 ) * ( i - 1 ) + r ( 3 ) * ( j - 1 ) + ( k - 1 ) + 1 end function counter !*********************************************************************** pure subroutine gauss ( order , abscissae , weights ) !! Provide Gaussian lineature abscissae and weights given the order, for domain [-1, 1] integer , intent ( in ) :: order !! Order of integration real ( rk ), intent ( out ) :: abscissae ( order ) !! Abscissae (coordinates) real ( rk ), intent ( out ) :: weights ( order ) !! Weights select case ( order ) ! 1 point case ( 1 ) abscissae ( 1 ) = 0 weights ( 1 ) = 2 ! 2 point case ( 2 ) block real ( rk ), parameter :: sqrt13 = sqrt ( 1.0_rk / 3 ) abscissae = [ - sqrt13 , sqrt13 ] weights = [ 1.0_rk , 1.0_rk ] end block ! 3 point case ( 3 ) block real ( rk ), parameter :: sqrt35 = sqrt ( 0.6_rk ) real ( rk ), parameter :: frac59 = 5.0_rk / 9 real ( rk ), parameter :: frac89 = 8.0_rk / 9 abscissae = [ - sqrt35 , 0.0_rk , sqrt35 ] weights = [ frac59 , frac89 , frac59 ] end block ! 4 point case ( 4 ) block real ( rk ), parameter :: sr4d8 = sqrt ( 4.8_rk ) real ( rk ), parameter :: sr30 = sqrt ( 3 0.0_rk ) real ( rk ), parameter :: root1 = sqrt (( 3.0_rk - sr4d8 ) / 7 ) real ( rk ), parameter :: root2 = sqrt (( 3.0_rk + sr4d8 ) / 7 ) real ( rk ), parameter :: frac1 = 0.5_rk + sr30 / 36 real ( rk ), parameter :: frac2 = 0.5_rk - sr30 / 36 abscissae = [ - root2 , - root1 , root1 , root2 ] weights = [ frac2 , frac1 , frac1 , frac2 ] end block ! 5 point case ( 5 ) block real ( rk ), parameter :: sr107 = sqrt ( 1 0.0_rk / 7 ) real ( rk ), parameter :: sr70 = sqrt ( 7 0.0_rk ) real ( rk ), parameter :: root1 = sqrt ( 5.0_rk - 2 * sr107 ) / 3 real ( rk ), parameter :: root2 = sqrt ( 5.0_rk + 2 * sr107 ) / 3 real ( rk ), parameter :: frac1 = ( 32 2.0_rk + 13 * sr70 ) / 900 real ( rk ), parameter :: frac2 = ( 32 2.0_rk - 13 * sr70 ) / 900 abscissae = [ - root2 , - root1 , 0.0_rk , root1 , root2 ] weights = [ frac2 , frac1 , 12 8.0_rk / 225 , frac1 , frac2 ] end block end select end subroutine gauss !*********************************************************************** end module cubatures","tags":"","url":"sourcefile/cubatures.f90.html"},{"title":"shapefuncs.f90 – easy","text":"Source Code module shapefuncs !! Procedures for evaluating shape and map functions and derivatives for !! triangles, quadrilateral, tetrahedron, and hexahedron elements !! Use cubature module with derived type use iso_fortran_env , only : ik => int32 , rk => real64 , stdout => output_unit use cubatures , only : cubature , counter implicit none private integer , parameter :: shaporders ( * ) = [ 4 , 4 , 4 , 4 , 2 ] public :: shaporders abstract interface !! Abstract interface to allow procedure pointers pure module subroutine lagrpoly ( order , x , func , derv , curv ) integer ( ik ), intent ( in ) :: order real ( rk ), intent ( in ) :: x real ( rk ), intent ( out ) :: func ( order + 1 ), derv ( order + 1 ), curv ( order + 1 ) end subroutine lagrpoly end interface type :: Shapefunc !! Includes Lagrange shape functions, linear - quartic, over the domains !!          [-1, 1] and [0, 1] !! First and second order mapping functions for [-1, 1] with infinity at 1 !! Note: Cubatures for tetrahedra use body coordinates, and the condition !!       x1 + x2 + x3 + x4 = 1 allows the elimination of the final !!       coordinate (likewise with triangles) character ( 3 ) :: elmtype = \"\" !! Element type integer ( ik ) :: dime = 0 !! Dimension integer ( ik ) :: order = 0 !! Order integer ( ik ) :: nodes = 0 !! Nodes integer ( ik ) :: points = 0 !! Cubature points character ( 3 ) :: inf ( 3 ) = [ \"FIN\" , \"FIN\" , \"FIN\" ] !! Infinitude real ( rk ), allocatable :: func (:,:) !! Shape function values (nodes,points) real ( rk ), allocatable :: derv (:,:,:) !! Shape function first derivatives (dimension,nodes,points) real ( rk ), allocatable :: curv (:,:,:,:) !! Shape function second derivatives (dimension,dimension,nodes,points) ! Internally useful ! Function pointers procedure ( lagrpoly ), pointer , nopass :: lagrange1 , lagrange2 , lagrange3 integer ( ik ), allocatable :: seq (:,:) !! Nodal numbering sequence integer :: ounit = stdout contains ! Fulfill object requirements procedure :: check procedure :: summary procedure :: show procedure :: numbering procedure :: destroy ! Unique procedures procedure :: set procedure :: eval final :: destroy_final end type Shapefunc public :: Shapefunc contains !*********************************************************************** pure function check ( self ) !! Check integrity of instance class ( shapefunc ), intent ( in ) :: self logical :: check check = ( allocated ( self % func ) . neqv . allocated ( self % derv )) end function check !*********************************************************************** subroutine summary ( self ) !! Summary contents to file class ( shapefunc ), intent ( in ) :: self associate ( u => self % ounit ) write ( u , \"(A20,A)\" ) \"Element type: \" , self % elmtype write ( u , \"(A20,I0)\" ) \"Element dimension: \" , self % dime write ( u , \"(A20,I0)\" ) \"Element orders: \" , self % order write ( u , \"(A20,I0)\" ) \"Element nodes: \" , self % nodes write ( u , \"(A20,I0)\" ) \"Element points: \" , self % points write ( u , \"(A20,3(A3,:,','))\" ) \"Element infinitude: \" , self % inf end associate end subroutine summary !*********************************************************************** subroutine show ( self ) !! Print shape function values and derivatives to terminal class ( Shapefunc ), intent ( in ) :: self integer ( ik ) :: g , n character ( 11 ) :: fmt1 = \"*(x,F20.15)\" ! Information write ( self % ounit , \"(A)\" ) \"SHAPE FUNCTION DATA\" write ( self % ounit , \"(A20,A)\" ) \"Element type: \" , self % elmtype write ( self % ounit , \"(A20,I0)\" ) \"Nodes: \" , self % nodes write ( self % ounit , \"(A20,I0)\" ) \"Cubature points: \" , self % points if ( any ( self % inf /= \"FIN\" )) then do n = 1 , self % dime select case ( self % inf ( n )) case ( \"FIN\" ) write ( self % ounit , \"(A,I0,A)\" ) \"Direction \" , n , \" is finite\" case ( \"INF\" ) write ( self % ounit , \"(A,I0,A)\" ) \"Direction \" , n , \" is infinite\" case ( \"CHP\" ) write ( self % ounit , \"(A,I0,A)\" ) \"Direction \" , n , \" is chopped\" end select end do ! n else write ( self % ounit , \"(A)\" ) \"All directions have standard domain\" end if select case ( self % elmtype ) ! Information on hexahedra and quadrilaterals case ( \"QUA\" , \"HEX\" ) write ( self % ounit , \"(A,I1,A)\" ) \"Point, node, func, derv (\" , self % dime , \")\" do g = 1 , self % points do n = 1 , self % nodes write ( self % ounit , \"(2I4,\" // fmt1 // \")\" ) g , n , self % func ( n , g ), self % derv (:, n , g ) end do ! n write ( self % ounit , \"(A8,\" // fmt1 // \")\" ) \"Check: \" , sum ( self % func ( :, g )), & sum ( self % derv (:,:, g ), 2 ) end do ! g ! Information on tetrahedra and triangles case ( \"TRI\" , \"TET\" ) write ( self % ounit , \"(A,I1,A)\" ) \"Point, node, func, derv (\" , self % dime , \")\" do g = 1 , self % points do n = 1 , self % nodes write ( self % ounit , \"(2I4,\" // fmt1 // \")\" ) g , n , self % func ( n , g ), self % derv (:, n , g ) end do ! n write ( self % ounit , \"(A8,\" // fmt1 // \")\" ) \"Check: \" , sum ( self % func (:, g )), & sum ( self % derv (:,:, g ), 2 ) end do ! g ! Information on wedges case ( \"WEJ\" ) write ( self % ounit , \"(A,I1,A)\" ) \"Point, node, func, derv (\" , self % dime , \")\" do g = 1 , self % points do n = 1 , self % nodes write ( self % ounit , \"(2I4,\" // fmt1 // \")\" ) g , n , self % func ( n , g ), self % derv (:, n , g ) end do ! n write ( self % ounit , \"(A8,\" // fmt1 // \")\" ) \"Check: \" , sum ( self % func (:, g )), & sum ( self % derv (:,:, g ), 2 ) end do ! g end select write ( self % ounit , * ) end subroutine show !*********************************************************************** subroutine numbering ( self ) !! Print node numbers and coordinates class ( shapefunc ), intent ( in ) :: self integer :: i , j , k integer :: m , n real ( rk ) :: coords ( self % dime , self % nodes ) character ( * ), parameter :: fmt1 = \"(I3,') ',*(F8.4,:,', '))\" select case ( self % elmtype ) case ( \"LIN\" ) ! Assemble coordinates do i = 1 , self % order + 1 n = counter ( i , 1 , 1 ,[ self % order + 1 , 1 , 1 ]) m = self % seq ( 1 , n ) coords ( 1 , m ) = - 1.0_rk + 2.0_rk * ( i - 1 ) / self % order end do ! j ! Print coordinates do i = 1 , self % nodes write ( self % ounit , fmt1 ) i , coords (:, i ) end do ! i case ( \"QUA\" ) ! Assemble coordinates do i = 1 , self % order + 1 do j = 1 , self % order + 1 n = counter ( i , j , 1 ,[ self % order + 1 , self % order + 1 , 1 ]) m = self % seq ( 1 , n ) coords ( 1 , m ) = - 1.0_rk + 2.0_rk * ( j - 1 ) / self % order coords ( 2 , m ) = - 1.0_rk + 2.0_rk * ( i - 1 ) / self % order end do ! j end do ! j ! Print coordinates do i = 1 , self % nodes write ( self % ounit , fmt1 ) i , coords (:, i ) end do ! i case ( \"TRI\" ) ! Assemble coordinates do i = 1 , self % nodes coords ( 1 , i ) = 1.0_rk * ( self % seq ( 1 , i ) - 1 ) / self % order coords ( 2 , i ) = 1.0_rk * ( self % seq ( 2 , i ) - 1 ) / self % order end do ! j ! Print coordinates do i = 1 , self % nodes write ( self % ounit , fmt1 ) i , coords (:, i ), 1 - sum ( coords (:, i )) end do ! i case ( \"HEX\" ) ! Assemble coordinates do i = 1 , self % order + 1 do j = 1 , self % order + 1 do k = 1 , self % order + 1 n = counter ( i , j , k ,[ self % order + 1 , self % order + 1 , self % order + 1 ]) m = self % seq ( 1 , n ) coords ( 1 , m ) = - 1.0_rk + 2.0_rk * ( k - 1 ) / self % order coords ( 2 , m ) = - 1.0_rk + 2.0_rk * ( j - 1 ) / self % order coords ( 3 , m ) = - 1.0_rk + 2.0_rk * ( i - 1 ) / self % order end do ! k end do ! j end do ! j ! Print coordinates do i = 1 , self % nodes write ( self % ounit , fmt1 ) i , coords (:, i ) end do ! i case ( \"TET\" ) ! Assemble coordinates do i = 1 , self % nodes coords ( 1 , i ) = 1.0_rk * ( self % seq ( 1 , i ) - 1 ) / self % order coords ( 2 , i ) = 1.0_rk * ( self % seq ( 2 , i ) - 1 ) / self % order coords ( 3 , i ) = 1.0_rk * ( self % seq ( 3 , i ) - 1 ) / self % order end do ! j ! Print coordinates do i = 1 , self % nodes write ( self % ounit , fmt1 ) i , coords (:, i ), 1 - sum ( coords (:, i )) end do ! i case ( \"WEJ\" ) write ( self % ounit , \"(A)\" ) \"TODO\" end select end subroutine numbering !*********************************************************************** pure subroutine destroy ( self ) !! Reset type to initial state class ( Shapefunc ), intent ( inout ) :: self self % elmtype = \"\" self % order = 0 self % nodes = 0 self % points = 0 self % inf = \"FIN\" if ( allocated ( self % func )) deallocate ( self % func ) if ( allocated ( self % derv )) deallocate ( self % derv ) if ( allocated ( self % curv )) deallocate ( self % curv ) if ( allocated ( self % seq )) deallocate ( self % seq ) end subroutine destroy !*********************************************************************** pure subroutine destroy_final ( self ) !! Destroy derived type type ( Shapefunc ), intent ( inout ) :: self call self % destroy () end subroutine destroy_final !*********************************************************************** pure subroutine set ( self , cube , order , infin ) !! Set shape functions given a cubature and a shape function code !! - cubature and shape functions must be compatible class ( Shapefunc ), intent ( inout ) :: self class ( Cubature ), intent ( in ) :: cube !! Cubature derived type integer ( ik ), intent ( in ) :: order !! Shape function order character ( 3 ), intent ( in ), optional :: infin (:) !! Infinitude or chopitude along each direction integer ( ik ) :: i integer ( ik ) :: mem integer ( ik ), parameter :: tri ( 4 ) = [ 3 , 6 , 10 , 15 ] integer ( ik ), parameter :: tet ( 4 ) = [ 4 , 10 , 20 , 35 ] integer ( ik ), parameter :: wej ( 4 ) = [ 6 , 18 , 40 , 75 ] ! Wipe any existing data if ( self % elmtype /= \"\" ) then call self % destroy () end if ! Read inputs and prepare memory ! Read for infinite domains if ( present ( infin )) then self % inf = \"FIN\" self % inf ( 1 : size ( infin )) = infin else self % inf = \"FIN\" end if ! Set function pointers to default self % lagrange1 => lagrfull self % lagrange2 => lagrfull self % lagrange3 => lagrfull ! Set parameters self % elmtype = cube % elmtype self % dime = cube % dime self % order = order mem = 0 ! Set particular pointers select case ( self % elmtype ) case ( \"HEX\" , \"QUA\" , \"LIN\" ) self % nodes = ( self % order + 1 ) ** self % dime if ( \"INF\" == self % inf ( 1 )) self % lagrange1 => lagrinf if ( \"INF\" == self % inf ( 2 )) self % lagrange2 => lagrinf if ( \"INF\" == self % inf ( 3 )) self % lagrange3 => lagrinf mem = 1 case ( \"TET\" ) self % nodes = tet ( self % order ) self % lagrange1 => lagrhalf self % lagrange2 => lagrhalf self % lagrange3 => lagrhalf mem = 4 case ( \"TRI\" ) self % nodes = tri ( self % order ) self % lagrange1 => lagrhalf self % lagrange2 => lagrhalf self % lagrange3 => lagrhalf mem = 3 case ( \"WEJ\" ) self % nodes = wej ( self % order ) self % lagrange1 => lagrhalf self % lagrange2 => lagrhalf mem = 4 end select ! Take cubature points self % points = cube % points ! Allocate function and derivative memory, and working sequence memory allocate ( self % func ( 1 : self % nodes , 1 : self % points )) allocate ( self % derv ( 1 : self % dime , 1 : self % nodes , 1 : self % points )) allocate ( self % curv ( 1 : self % dime , 1 : self % dime , 1 : self % nodes , 1 : self % points )) allocate ( self % seq ( mem , self % nodes )) !!! Set order and sequences select case ( self % elmtype ) ! Line case ( \"LIN\" ) select case ( self % order ) case ( 0 ) self % seq ( 1 ,:) = [ 1 ] case ( 1 ) self % seq ( 1 ,:) = [ 1 , 2 ] case ( 2 ) self % seq ( 1 ,:) = [ 1 , 3 , 2 ] case ( 3 ) self % seq ( 1 ,:) = [ 1 , 3 , 4 , 2 ] case ( 4 ) self % seq ( 1 ,:) = [ 1 , 3 , 4 , 5 , 2 ] end select ! Quadrilateral case ( \"QUA\" ) select case ( self % order ) case ( 0 ) self % seq ( 1 ,:) = [ 1 ] case ( 1 ) self % seq ( 1 ,:) = [ 1 , 2 , 4 , 3 ] case ( 2 ) self % seq ( 1 ,:) = [ 1 , 5 , 2 , 8 , 9 , 6 , 4 , 7 , 3 ] case ( 3 ) self % seq ( 1 ,:) = [ 1 , 5 , 6 , 2 , 12 , 13 , 14 , 7 , 11 , 16 , 15 , 8 , 4 , 10 , 9 , 3 ] case ( 4 ) self % seq ( 1 ,:) = [( i , i = 1 , 25 )] case default error stop \"Shapefunc%set: Invalid order for quadrilateral\" end select ! Triangle case ( \"TRI\" ) select case ( self % order ) case ( 1 ) self % seq (:, 1 ) = [ 1 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 1 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 1 ] self % seq = self % seq + 1 case ( 2 ) ! Vertices self % seq (:, 1 ) = [ 2 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 2 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 2 ] ! Edges self % seq (:, 4 ) = [ 1 , 1 , 0 ] self % seq (:, 5 ) = [ 0 , 1 , 1 ] self % seq (:, 6 ) = [ 1 , 0 , 1 ] self % seq = self % seq + 1 case ( 3 ) ! Vertices self % seq (:, 1 ) = [ 3 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 3 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 3 ] ! Edges self % seq (:, 4 ) = [ 2 , 1 , 0 ] self % seq (:, 5 ) = [ 1 , 2 , 0 ] self % seq (:, 6 ) = [ 0 , 2 , 1 ] self % seq (:, 7 ) = [ 0 , 1 , 2 ] self % seq (:, 8 ) = [ 1 , 0 , 2 ] self % seq (:, 9 ) = [ 2 , 0 , 1 ] ! Face self % seq (:, 10 ) = [ 1 , 1 , 1 ] self % seq = self % seq + 1 case default error stop \"Shapefunc%set: Invalid order for triangle\" end select ! Hexahedron case ( \"HEX\" ) select case ( self % order ) case ( 0 ) self % seq ( 1 ,:) = [ 1 ] ! Linear full Lagrange polynomials - 2x2x2 = 8 nodes case ( 1 ) self % seq ( 1 ,:) = [ 1 , 2 , 4 , 3 , 5 , 6 , 8 , 7 ] ! Quadratic full Lagrange polynomials - 3x3x3 = 27 nodes case ( 2 ) self % seq ( 1 ,:) = [ 1 , 9 , 2 , 12 , 21 , 10 , 4 , 11 , 3 , & 17 , 25 , 18 , 23 , 27 , 24 , 20 , 26 , 19 , & 5 , 13 , 6 , 16 , 22 , 14 , 8 , 15 , 7 ] ! Cubic full Lagrange polynomials - 4x4x4 = 64 nodes case ( 3 ) self % seq ( 1 ,:) = [( i , i = 1 , 64 )] ! Quartic full Lagrange polynomials - 5x5x5 = 125 nodes case ( 4 ) self % seq ( 1 ,:) = [( i , i = 1 , 125 )] case default error stop \"Shapefunc%set: Invalid order for hexahedron\" end select ! Tetrahedron case ( \"TET\" ) select case ( self % order ) ! Linear half Lagrange polynomials - 4 nodes case ( 1 ) self % seq (:, 1 ) = [ 1 , 0 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 1 , 0 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 1 , 0 ] self % seq (:, 4 ) = [ 0 , 0 , 0 , 1 ] self % seq = self % seq + 1 ! Quadratic half Lagrange polynomials - 10 nodes case ( 2 ) ! Vertices self % seq (:, 1 ) = [ 2 , 0 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 2 , 0 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 2 , 0 ] self % seq (:, 4 ) = [ 0 , 0 , 0 , 2 ] ! Edges self % seq (:, 5 ) = [ 1 , 1 , 0 , 0 ] self % seq (:, 6 ) = [ 0 , 1 , 1 , 0 ] self % seq (:, 7 ) = [ 1 , 0 , 1 , 0 ] self % seq (:, 8 ) = [ 1 , 0 , 0 , 1 ] self % seq (:, 9 ) = [ 0 , 1 , 0 , 1 ] self % seq (:, 10 ) = [ 0 , 0 , 1 , 1 ] self % seq = self % seq + 1 ! Cubic half Lagrange polynomials - 10 nodes case ( 3 ) ! Vertices self % seq (:, 1 ) = [ 3 , 0 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 3 , 0 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 3 , 0 ] self % seq (:, 4 ) = [ 0 , 0 , 0 , 3 ] ! Edges self % seq (:, 5 ) = [ 2 , 1 , 0 , 0 ] self % seq (:, 6 ) = [ 1 , 2 , 0 , 0 ] self % seq (:, 7 ) = [ 0 , 2 , 1 , 0 ] self % seq (:, 8 ) = [ 0 , 1 , 2 , 0 ] self % seq (:, 9 ) = [ 1 , 0 , 2 , 0 ] self % seq (:, 10 ) = [ 2 , 0 , 1 , 0 ] self % seq (:, 11 ) = [ 2 , 0 , 0 , 1 ] self % seq (:, 12 ) = [ 1 , 0 , 0 , 2 ] self % seq (:, 13 ) = [ 0 , 2 , 0 , 1 ] self % seq (:, 14 ) = [ 0 , 1 , 0 , 2 ] self % seq (:, 15 ) = [ 0 , 0 , 2 , 1 ] self % seq (:, 16 ) = [ 0 , 0 , 1 , 2 ] ! Faces self % seq (:, 17 ) = [ 1 , 1 , 1 , 0 ] self % seq (:, 18 ) = [ 1 , 1 , 0 , 1 ] self % seq (:, 19 ) = [ 0 , 1 , 1 , 1 ] self % seq (:, 20 ) = [ 1 , 0 , 1 , 1 ] self % seq = self % seq + 1 case default error stop \"Shapefunc%set: Invalid order for tetrahedron\" end select ! Wedge case ( \"WEJ\" ) select case ( self % order ) ! Linear polynomials - 6 nodes case ( 1 ) ! Bottom self % seq (:, 1 ) = [ 1 , 0 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 1 , 0 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 1 , 0 ] ! Top self % seq (:, 4 ) = [ 1 , 0 , 0 , 1 ] self % seq (:, 5 ) = [ 0 , 1 , 0 , 1 ] self % seq (:, 6 ) = [ 0 , 0 , 1 , 1 ] self % seq = self % seq + 1 ! Quadratic polynomials - 18 nodes case ( 2 ) ! Bottom self % seq (:, 1 ) = [ 2 , 0 , 0 , 0 ] self % seq (:, 2 ) = [ 0 , 2 , 0 , 0 ] self % seq (:, 3 ) = [ 0 , 0 , 2 , 0 ] self % seq (:, 4 ) = [ 2 , 0 , 0 , 2 ] self % seq (:, 5 ) = [ 0 , 2 , 0 , 2 ] self % seq (:, 6 ) = [ 0 , 0 , 2 , 2 ] ! Top self % seq (:, 7 ) = [ 1 , 1 , 0 , 0 ] self % seq (:, 8 ) = [ 0 , 1 , 1 , 0 ] self % seq (:, 9 ) = [ 1 , 0 , 1 , 0 ] self % seq (:, 10 ) = [ 1 , 1 , 0 , 2 ] self % seq (:, 11 ) = [ 0 , 1 , 1 , 2 ] self % seq (:, 12 ) = [ 1 , 0 , 1 , 2 ] ! Middle self % seq (:, 13 ) = [ 2 , 0 , 0 , 1 ] self % seq (:, 14 ) = [ 0 , 2 , 0 , 1 ] self % seq (:, 15 ) = [ 0 , 0 , 2 , 1 ] self % seq (:, 16 ) = [ 1 , 1 , 0 , 1 ] self % seq (:, 17 ) = [ 0 , 1 , 1 , 1 ] self % seq (:, 18 ) = [ 1 , 0 , 1 , 1 ] self % seq = self % seq + 1 case default error stop \"Shapefunc%set: Invalid order for wedge\" end select end select !!! Calculate shape functions and derivatives ! Loop over cubature points do i = 1 , self % points call self % eval ( cube % abscissae (:, i ), & self % func (:, i ), self % derv (:,:, i ), self % curv (:,:,:, i )) end do ! i end subroutine set !*********************************************************************** pure subroutine eval ( self , cord , func , derv , curv ) !! Evaluate shape functions and derivatives at a point class ( Shapefunc ), intent ( in ) :: self real ( rk ), intent ( in ) :: cord ( self % dime ) !! Point at which to evaluate real ( rk ), intent ( out ) :: func ( self % nodes ) !! Shape function values real ( rk ), intent ( out ) :: derv ( self % dime , self % nodes ) !! Shape function derivatives real ( rk ), intent ( out ) :: curv ( self % dime , self % dime , self % nodes ) !! Shape function second derivatives integer ( ik ) :: i , j , k , m , n integer ( ik ) :: a ( 4 ) real ( rk ) :: r real ( rk ) :: f ( 5 , 4 ) ! Directional shape function values      (node,coordinate) real ( rk ) :: d ( 5 , 4 ) ! Directional shape function derivatives (node,coordinate) real ( rk ) :: c ( 5 , 4 ) ! Directional shape function second derivatives real ( rk ) :: coord ( 3 ) ! Copy abscissae coord ( 3 ) = 0 coord ( 1 : self % dime ) = cord ( 1 : self % dime ) ! Calculate lagrange polynomials and derivatives at each abscissa and for each node f = 0 d = 0 c = 0 if ( \"CHP\" == self % inf ( 1 )) then call self % lagrange1 ( self % order + 1 , coord ( 1 ), & f ( 1 : self % order + 2 , 1 ), d ( 1 : self % order + 2 , 1 ), c ( 1 : self % order + 2 , 1 )) else call self % lagrange1 ( self % order , coord ( 1 ), & f ( 1 : self % order + 1 , 1 ), d ( 1 : self % order + 1 , 1 ), c ( 1 : self % order + 1 , 1 )) end if if ( \"CHP\" == self % inf ( 2 )) then call self % lagrange2 ( self % order + 1 , coord ( 2 ), & f ( 1 : self % order + 2 , 2 ), d ( 1 : self % order + 2 , 2 ), c ( 1 : self % order + 2 , 2 )) else call self % lagrange2 ( self % order , coord ( 2 ), & f ( 1 : self % order + 1 , 2 ), d ( 1 : self % order + 1 , 2 ), c ( 1 : self % order + 1 , 2 )) end if if ( self % dime == 3 ) then if ( \"CHP\" == self % inf ( 3 )) then call self % lagrange3 ( self % order + 1 , coord ( 3 ), & f ( 1 : self % order + 2 , 3 ), d ( 1 : self % order + 2 , 3 ), c ( 1 : self % order + 2 , 3 )) else call self % lagrange3 ( self % order , coord ( 3 ), & f ( 1 : self % order + 1 , 3 ), d ( 1 : self % order + 1 , 3 ), c ( 1 : self % order + 1 , 3 )) end if end if select case ( self % elmtype ) ! Calculate lineal shape functions and derivatives case ( \"LIN\" ) do i = 1 , self % order + 1 n = counter ( i , 1 , 1 ,[ self % order + 1 , 1 , 1 ]) m = self % seq ( 1 , n ) func ( m ) = f ( i , 1 ) derv ( 1 , m ) = d ( i , 1 ) curv ( 1 , 1 , m ) = c ( i , 1 ) end do ! i, j ! Calculate quadrilateral shape functions and derivatives case ( \"QUA\" ) do i = 1 , self % order + 1 do j = 1 , self % order + 1 n = counter ( i , j , 1 ,[ self % order + 1 , self % order + 1 , 1 ]) m = self % seq ( 1 , n ) func ( m ) = f ( j , 1 ) * f ( i , 2 ) derv ( 1 , m ) = d ( j , 1 ) * f ( i , 2 ) derv ( 2 , m ) = f ( j , 1 ) * d ( i , 2 ) curv ( 1 , 1 , m ) = c ( j , 1 ) * f ( i , 2 ) curv ( 2 , 1 , m ) = d ( j , 1 ) * d ( i , 2 ) curv ( 1 , 2 , m ) = curv ( 2 , 1 , m ) curv ( 2 , 2 , m ) = f ( j , 1 ) * c ( i , 2 ) end do ! j end do ! i ! Calculate triangle shape functions case ( \"TRI\" ) r = 1 - coord ( 1 ) - coord ( 2 ) call self % lagrange1 ( self % order , r , f (:, 3 ), d (:, 3 ), c (:, 3 )) do m = 1 , self % nodes a ( 1 : 3 ) = self % seq (:, m ) func ( m ) = f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) derv ( 1 , m ) = d ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) - & f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) derv ( 2 , m ) = f ( a ( 1 ), 1 ) * d ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) - & f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) curv ( 1 , 1 , m ) = c ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) - & 2 * d ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) + & f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * c ( a ( 3 ), 3 ) curv ( 2 , 1 , m ) = d ( a ( 1 ), 1 ) * d ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) - & d ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) - & f ( a ( 1 ), 1 ) * d ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) + & f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * c ( a ( 3 ), 3 ) curv ( 1 , 2 , m ) = curv ( 2 , 1 , m ) curv ( 2 , 2 , m ) = f ( a ( 1 ), 1 ) * c ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) - & 2 * f ( a ( 1 ), 1 ) * d ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) + & f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * c ( a ( 3 ), 3 ) end do ! i ! Calculate hexahedron shape functions case ( \"HEX\" ) do i = 1 , self % order + 1 do j = 1 , self % order + 1 do k = 1 , self % order + 1 n = counter ( i , j , k ,[ self % order + 1 , self % order + 1 , self % order + 1 ]) m = self % seq ( 1 , n ) func ( m ) = f ( k , 1 ) * f ( j , 2 ) * f ( i , 3 ) derv ( 1 , m ) = d ( k , 1 ) * f ( j , 2 ) * f ( i , 3 ) derv ( 2 , m ) = f ( k , 1 ) * d ( j , 2 ) * f ( i , 3 ) derv ( 3 , m ) = f ( k , 1 ) * f ( j , 2 ) * d ( i , 3 ) curv ( 1 , 1 , m ) = c ( k , 1 ) * f ( j , 2 ) * f ( i , 3 ) curv ( 2 , 1 , m ) = d ( k , 1 ) * d ( j , 2 ) * f ( i , 3 ) curv ( 3 , 1 , m ) = d ( k , 1 ) * f ( j , 2 ) * d ( i , 3 ) curv ( 1 , 2 , m ) = curv ( 2 , 1 , m ) curv ( 2 , 2 , m ) = f ( k , 1 ) * c ( j , 2 ) * f ( i , 3 ) curv ( 3 , 2 , m ) = f ( k , 1 ) * d ( j , 2 ) * d ( i , 3 ) curv ( 1 , 3 , m ) = curv ( 3 , 1 , m ) curv ( 2 , 3 , m ) = curv ( 3 , 2 , m ) curv ( 3 , 3 , m ) = f ( k , 1 ) * f ( j , 2 ) * c ( i , 3 ) end do ! k end do ! j end do ! i ! Calculate tetrahedron shape functions ! Note the chain rule for handling the fourth body coordinate case ( \"TET\" ) r = 1 - coord ( 1 ) - coord ( 2 ) - coord ( 3 ) call self % lagrange1 ( self % order , r , f (:, 4 ), d (:, 4 ), c (:, 4 )) do m = 1 , self % nodes a = self % seq (:, m ) func ( m ) = f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) derv ( 1 , m ) = f ( a ( 1 ), 1 ) * d ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) - & d ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) derv ( 2 , m ) = f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) - & d ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) derv ( 3 , m ) = f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * d ( a ( 4 ), 4 ) - & d ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) !      curv(1,1,m) =   c(a(1),1)*f(a(2),2)*f(a(3),3)*f(a(4),4) - & !                    2*d(a(1),1)*f(a(2),2)*f(a(3),3)*d(a(4),4) + & !                      f(a(1),1)*f(a(2),2)*f(a(3),3)*c(a(4),4) !      curv(2,1,m) =   d(a(1),1)*d(a(2),2)*f(a(3),3)*f(a(4),4) - & !                      d(a(1),1)*f(a(2),2)*f(a(3),3)*d(a(4),4) - & !                      f(a(1),1)*d(a(2),2)*f(a(3),3)*d(a(4),4) + & !                      f(a(1),1)*f(a(2),2)*f(a(3),3)*c(a(4),4) !      curv(3,1,m) =   d(a(1),1)*f(a(2),2)*d(a(3),3)*f(a(4),4) - & !                      d(a(1),1)*f(a(2),2)*f(a(3),3)*f(a(4),4) - & !                      f(a(1),1)*f(a(2),2)*d(a(3),3)*d(a(4),4) + & !                      f(a(1),1)*f(a(2),2)*f(a(3),3)*c(a(4),4) !      curv(1,2,m) =   curv(2,1,m) !      curv(2,2,m) =   f(a(1),1)*c(a(2),2)*f(a(3),3)*f(a(4),4) - & !                    2*f(a(1),1)*d(a(2),2)*f(a(3),3)*f(a(4),4) + & !                      f(a(1),1)*f(a(2),2)*f(a(3),3)*c(a(4),4) !      curv(3,2,m) =   f(a(1),1)*d(a(2),2)*d(a(3),3)*f(a(4),4) - & !                      f(a(1),1)*d(a(2),2)*f(a(3),3)*d(a(4),4) - & !                      f(a(1),1)*f(a(2),2)*d(a(3),3)*d(a(4),4) + & !                      f(a(1),1)*f(a(2),2)*f(a(3),3)*c(a(4),4) !      curv(1,3,m) =   curv(3,1,m) !      curv(2,3,m) =   curv(3,2,m) !      curv(3,3,m) =   f(a(1),1)*f(a(2),2)*c(a(3),3)*f(a(4),4) - & !                    2*f(a(1),1)*f(a(2),2)*d(a(3),3)*d(a(4),4) + & !                      f(a(1),1)*f(a(2),2)*f(a(3),3)*c(a(4),4) end do ! curv = 0 ! Calculate wedge shape functions case ( \"WEJ\" ) r = 1 - coord ( 1 ) - coord ( 2 ) f (:, 4 ) = f (:, 3 ) d (:, 4 ) = d (:, 3 ) c (:, 4 ) = c (:, 3 ) call self % lagrange1 ( self % order , r , f (:, 3 ), d (:, 3 ), c (:, 3 )) do m = 1 , self % nodes a ( 1 : 4 ) = self % seq (:, m ) func ( m ) = f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) derv ( 1 , m ) = d ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) - & f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) derv ( 2 , m ) = f ( a ( 1 ), 1 ) * d ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) - & f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * d ( a ( 3 ), 3 ) * f ( a ( 4 ), 4 ) derv ( 3 , m ) = f ( a ( 1 ), 1 ) * f ( a ( 2 ), 2 ) * f ( a ( 3 ), 3 ) * d ( a ( 4 ), 4 ) end do ! m curv = 0 end select end subroutine eval !*********************************************************************** pure subroutine lagrfull ( order , x , func , derv , curv ) !! Provide lagrangian polynomials and derivatives for the domain [-1, 1] integer ( ik ), intent ( in ) :: order !! Polynomial order real ( rk ), intent ( in ) :: x !! Point at which to evaluate real ( rk ), intent ( out ) :: func ( abs ( order ) + 1 ) !! Polynomial values real ( rk ), intent ( out ) :: derv ( abs ( order ) + 1 ) !! Polynomial derivatives real ( rk ), intent ( out ) :: curv ( abs ( order ) + 1 ) !! Polynomial second derivatives select case ( order ) case ( 0 ) func = [ 1.0_rk ] derv = [ 0.0_rk ] curv = [ 0.0_rk ] case ( 1 ) func = [ - x + 1 , x + 1 ] / 2 derv = [ - 1.0_rk , 1.0_rk ] / 2 curv = [ 0.0_rk , 0.0_rk ] case ( 2 ) func = [ x * ( x - 1 ) / 2 , 1.0_rk - x ** 2 , x * ( x + 1 ) / 2 ] derv = [ x - 0.5 , - 2 * x , x + 0.5 ] curv = [ 1.0_rk , - 2.0_rk , 1.0_rk ] case ( 3 ) func = [ - ( 3 * x + 1 ) * ( 3 * x - 1 ) * ( x - 1 ),& 9 * ( x + 1 ) * ( 3 * x - 1 ) * ( x - 1 ),& - 9 * ( x + 1 ) * ( 3 * x + 1 ) * ( x - 1 ),& ( x + 1 ) * ( 3 * x + 1 ) * ( 3 * x - 1 ) ] / 16 derv = [ - 27 * x ** 2 + 18 * x + 1 ,& 9 * ( 9 * x ** 2 - 2 * x - 3 ),& 9 * ( - 9 * x ** 2 - 2 * x + 3 ),& 27 * x ** 2 + 18 * x - 1 ] / 16 curv = [ - 54 * x + 18 ,& 182 * x - 18 ,& - 182 * x - 18 ,& 54 * x + 18 ] / 16 case ( 4 ) func = [ ( 2 * x + 1 ) * x * ( 2 * x - 1 ) * ( x - 1 ) / 6 ,& - 4 * ( x + 1 ) * x * ( 2 * x - 1 ) * ( x - 1 ) / 3 ,& ( x + 1 ) * ( 2 * x + 1 ) * ( 2 * x - 1 ) * ( x - 1 ) ,& - 4 * ( x + 1 ) * ( 2 * x + 1 ) * x * ( x - 1 ) / 3 ,& ( x + 1 ) * ( 2 * x + 1 ) * x * ( 2 * x - 1 ) / 6 ] derv = [ ( 16 * x ** 3 - 12 * x ** 2 - 2 * x + 1 ) / 6 ,& - 4 * ( 8 * x ** 3 - 6 * x ** 2 - 4 * x + 1 ) / 3 ,& 16 * x ** 3 - 10 * x ,& - 4 * ( 8 * x ** 3 + 6 * x ** 2 - 4 * x - 1 ) / 3 ,& ( 16 * x ** 3 + 12 * x ** 2 - 2 * x - 1 ) / 6 ] curv = [ ( 48 * x ** 2 - 24 * x - 2 ) / 6 ,& - 4 * ( 24 * x ** 2 - 12 * x - 4 ) / 3 ,& 48 * x ** 2 - 10 ,& - 4 * ( 24 * x ** 3 + 12 * x - 4 ) / 3 ,& ( 48 * x ** 2 + 24 * x - 2 ) / 6 ] case default error stop \"shapefuncs: lagrfull invalid order\" end select end subroutine lagrfull !*********************************************************************** pure subroutine lagrhalf ( order , x , func , derv , curv ) !! Provide lagrangian polynomials and derivatives for the domain [0, 1] integer ( ik ), intent ( in ) :: order !! Polynomial order real ( rk ), intent ( in ) :: x !! Point at which to evaluate real ( rk ), intent ( out ) :: func ( abs ( order ) + 1 ) !! Polynomial values real ( rk ), intent ( out ) :: derv ( abs ( order ) + 1 ) !! Polynomial derivatives real ( rk ), intent ( out ) :: curv ( abs ( order ) + 1 ) !! Polynomial second derivatives select case ( order ) case ( 1 ) func = [ 1.0_rk , x ] derv = [ 0.0_rk , 1.0_rk ] curv = [ 0.0_rk , 0.0_rk ] case ( 2 ) func = [ 1.0_rk , 2 * x , x * ( 2 * x - 1 )] derv = [ 0.0_rk , 2.0_rk , 4 * x - 1 ] curv = [ 0.0_rk , 0.0_rk , 4.0_rk ] case ( 3 ) func = [ 1.0_rk , 3 * x , 3 * x * ( 3 * x - 1 ) / 2 , x * ( 3 * x - 1 ) * ( 3 * x - 2 ) / 2 ] derv = [ 0.0_rk , 3.0_rk , 9 * x - 1.5 , 27 * x ** 2 / 2 - 9 * x + 1 ] curv = [ 0.0_rk , 0.0_rk , 9.0_rk , 27 * x - 9 ] case ( 4 ) func = [ 1.0_rk , 4 * x , 2 * x * ( 4 * x - 1 ), 4 * x * ( 4 * x - 1 ) * ( 2 * x - 1 ) / 3 , x * ( 4 * x - 1 ) * ( 2 * x - 1 ) * ( 4 * x - 3 ) / 3 ] derv = [ 0.0_rk , 4.0_rk , 16 * x - 2 , 32 * x ** 2 - 16 * x + 4.0_rk / 3 , 128 * x ** 3 / 3 + 48 * x ** 2 + 44 * x / 3 - 1 ] curv = [ 0.0_rk , 0.0_rk , 1 6.0_rk , 64 * x - 16 , 128 * x ** 2 + 48 * x + 4 4.0_rk / 3 ] end select end subroutine lagrhalf !*********************************************************************** pure subroutine lagrinf ( order , x , func , derv , curv ) !! Provide lagrangian polynomials and derivatives for the domain [-1, 1], !! for infinity at 1 integer ( ik ), intent ( in ) :: order !! Polynomial order real ( rk ), intent ( in ) :: x !! Point at which to evaluate real ( rk ), intent ( out ) :: func ( abs ( order ) + 1 ) !! Polynomial values real ( rk ), intent ( out ) :: derv ( abs ( order ) + 1 ) !! Polynomial derivatives real ( rk ), intent ( out ) :: curv ( abs ( order ) + 1 ) !! Polynomial second derivatives select case ( order ) ! To complement linear shape functions case ( 1 ) func = [ - 2 * x , 1 + x ] / ( 1 - x ) derv = [ - 2.0_rk , 2.0_rk ] / ( 1 - x ) ** 2 curv = [ - 2.0_rk , 2.0_rk ] / ( 1 - x ) ** 3 ! To complement quadratic shape functions case ( 2 ) func = [( 3 * x + 1 ) * ( 3 * x - 1 ) / 4 , - ( x + 1 ) * ( 3 * x - 1 ), ( x + 1 ) * ( 3 * x + 1 ) / 4 ] / ( 1 - x ) derv = [( - 9 * x * x + 18 * x - 1 ) / 4 , 3 * x * x - 6 * x - 1 , ( - 3 * x * x + 6 * x + 5 ) / 4 ] / ( 1 - x ) ** 2 curv = [ 4.0_rk , 8.0_rk , 4.0_rk ] / ( 1 - x ) ** 3 ! To complement cubic shape functions case ( 3 ) func = [ - 2 * ( 2 * x + 1 ) * x * ( 2 * x - 1 ) / 3 , & 3 * ( x + 1 ) * x * ( 2 * x - 1 ) , & - ( x + 1 ) * ( 2 * x + 1 ) * ( 2 * x - 1 ) , & ( x + 1 ) * ( 2 * x + 1 ) * x / 3 ] / ( 1 - x ) derv = [ 2 * ( 8 * x ** 3 - 12 * x * x + 1 ) / 3 , & - 3 * ( 4 * x ** 3 - 5 * x * x - 2 * x + 1 ), & 8 * x ** 3 - 8 * x * x - 8 * x + 2 , & ( - 4 * x ** 3 + 3 * x * x + 6 * x + 1 ) / 3 ] / ( 1 - x ) ** 2 curv = 0 ! To complement quartic shape functions case ( 4 ) func = [ ( 5 * x + 3 ) * ( 5 * x + 1 ) * ( 5 * x - 1 ) * ( 5 * x - 3 ) / 192 , & - ( x + 1 ) * ( 5 * x + 1 ) * ( 5 * x - 1 ) * ( 5 * x - 3 ) / 12 , & 3 * ( x + 1 ) * ( 5 * x + 3 ) * ( 5 * x - 1 ) * ( 5 * x - 3 ) / 32 , & - ( x + 1 ) * ( 5 * x + 3 ) * ( 5 * x + 1 ) * ( 5 * x - 3 ) / 24 , & ( x + 1 ) * ( 5 * x + 3 ) * ( 5 * x + 1 ) * ( 5 * x - 1 ) / 192 ] / ( 1 - x ) derv = [ ( - 1875 * x ** 4 + 2500 * x ** 3 + 250 * x * x - 500 * x + 9 ) / 192 , & ( 375 * x ** 4 - 400 * x ** 3 - 230 * x * x + 160 * x - 1 ) / 12 , & 3 * ( - 375 * x ** 4 + 300 * x ** 3 + 370 * x * x - 140 * x - 27 ) / 32 , & ( 375 * x ** 4 - 200 * x ** 3 - 470 * x * x + 40 * x + 63 ) / 24 , & ( - 375 * x ** 4 + 100 * x ** 3 + 530 * x * x + 140 * x - 11 ) / 192 ] / ( 1 - x ) ** 2 curv = 0 case default error stop \"shapefuncs: lagrinf invalid order\" end select end subroutine lagrinf !*********************************************************************** end module shapefuncs","tags":"","url":"sourcefile/shapefuncs.f90.html"},{"title":"shapefuncs_test.f90 – easy","text":"Source Code program shapefuncs_test !! Validate shape functions use iso_fortran_env , only : ik => int32 , rk => real64 , stdout => output_unit use cubatures , only : cubature , elmtypes use shapefuncs , only : shapefunc , shaporders implicit none integer :: g , i , j integer :: ord integer :: maxo ! real(rk) :: character ( 1 ) :: order character ( * ), parameter :: fmt1 = \"(A15,': ',$)\" type ( cubature ) :: scheme type ( shapefunc ) :: shape write ( * , \"(A)\" ) \"1D elements\" write ( * , fmt1 ) \"Line\" j = maxval ( maxloc ( index ( elmtypes , \"LIN\" ))) maxo = shaporders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"LIN\" , [ i ]) ! Standard domain call shape % set ( scheme , i ) do g = 1 , shape % points if (. not . is_zero ( sum ( shape % func (:, g )) - 1.0_rk )) then write ( * , * ) write ( * , * ) sum ( shape % func ) error stop \"order \" // order // \" standard: partition of unity failed\" end if if (. not . is_zero ( sum ( shape % derv ( 1 ,:, g )))) then write ( * , * ) write ( * , * ) sum ( shape % derv ( 1 ,:, g )) error stop \"order \" // order // \" standard: derivatives failed\" end if end do ! g ! Infinite domain call shape % set ( scheme , i , infin = [ \"INF\" ]) do g = 1 , shape % points if (. not . is_zero ( sum ( shape % func (:, g )) - 1.0_rk )) then write ( * , * ) write ( * , * ) sum ( shape % func ) error stop \"order \" // order // \" infinite: partition of unity failed\" end if if (. not . is_zero ( sum ( shape % derv ( 1 ,:, g )))) then write ( * , * ) write ( * , * ) sum ( shape % derv ( 1 ,:, g )) error stop \"order \" // order // \" infinite: derivatives failed\" end if end do ! g end do ! i write ( * , \"(A)\" ) \"passed\" contains pure elemental function is_zero ( r ) result ( z ) real ( rk ), intent ( in ) :: r logical :: z z = abs ( r ) < 1 0.0_rk ** ( - 12 ) end function is_zero end program shapefuncs_test","tags":"","url":"sourcefile/shapefuncs_test.f90.html"}]}